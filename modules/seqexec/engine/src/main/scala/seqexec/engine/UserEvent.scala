// Copyright (c) 2016-2018 Association of Universities for Research in Astronomy, Inc. (AURA)
// For license information see LICENSE or https://opensource.org/licenses/BSD-3-Clause

package seqexec.engine

import seqexec.model.Model.{ClientID, Observer}
import seqexec.model.UserDetails

import cats.effect.IO
import cats.implicits._
import fs2.Stream

/**
  * Events generated by the user.
  */
sealed trait UserEvent[+D <: Engine.Types] {
  def user: Option[UserDetails]
  def username: String = user.foldMap(_.username)
}

final case class Start(id: Sequence.Id, user: Option[UserDetails], clientId: ClientID) extends UserEvent[Nothing]
final case class Pause(id: Sequence.Id, user: Option[UserDetails]) extends UserEvent[Nothing]
final case class CancelPause(id: Sequence.Id, user: Option[UserDetails]) extends UserEvent[Nothing]
final case class Load(id: Sequence.Id, sequence: Sequence) extends UserEvent[Nothing] {
  val user: Option[UserDetails] = None
}
final case class Unload(id: Sequence.Id) extends UserEvent[Nothing] {
  val user: Option[UserDetails] = None
}
final case class Breakpoint(id: Sequence.Id, user: Option[UserDetails], step: Step.Id, v: Boolean) extends UserEvent[Nothing]
final case class SkipMark(id: Sequence.Id, user: Option[UserDetails], step: Step.Id, v: Boolean) extends UserEvent[Nothing]
//final case class SetOperator(name: Operator, user: Option[UserDetails]) extends UserEvent[Nothing]
final case class SetObserver(id: Sequence.Id, user: Option[UserDetails], name: Observer) extends UserEvent[Nothing]
//final case class SetConditions(conditions: Conditions, user: Option[UserDetails]) extends UserEvent[Nothing]
//final case class SetImageQuality(iq: ImageQuality, user: Option[UserDetails]) extends UserEvent[Nothing]
//final case class SetWaterVapor(wv: WaterVapor, user: Option[UserDetails]) extends UserEvent[Nothing]
//final case class SetSkyBackground(wv: SkyBackground, user: Option[UserDetails]) extends UserEvent[Nothing]
//final case class SetCloudCover(cc: CloudCover, user: Option[UserDetails]) extends UserEvent[Nothing]
final case class Poll(clientId: ClientID) extends UserEvent[Nothing] {
  val user: Option[UserDetails] = None
}
// Generic event to put a function in the main Stream process, which takes an
// action depending on the current state
final case class GetState[D <: Engine.Types](f: Engine.State[D#StateData] => IO[Option[Stream[IO, Event[D]]]]) extends UserEvent[D] {
  val user: Option[UserDetails] = None
}
// Generic event to put a function in the main Stream process, which takes an
// action depending on the current state of a specific sequence
final case class GetSeqState[D <: Engine.Types](id: Sequence.Id, f: Sequence.State => Option[Stream[IO, Event[D]]]) extends UserEvent[D] {
  val user: Option[UserDetails] = None
}
// Generic event to put a function in the main Process process, which changes the state
// depending on the current state
final case class ModifyState[D <: Engine.Types](f: Engine.State[D#StateData] => Engine.State[D#StateData], event: D#EventData) extends UserEvent[D] {
  val user: Option[UserDetails] = None
}
final case class ModifyStateF[D <: Engine.Types](f: Engine.State[D#StateData] => Engine.State[D#StateData], event: Engine.State[D#StateData] => D#EventData) extends UserEvent[D] {
  val user: Option[UserDetails] = None
}
// Calls a user given function in the main Stream process to stop an Action.
// It sets the Sequence to be stopped. The user function is called only if the Sequence is running.
final case class ActionStop[D <: Engine.Types](id: Sequence.Id, f: Sequence.State => Option[Stream[IO, Event[D]]]) extends UserEvent[D] {
  val user: Option[UserDetails] = None
}

// Uses `cont` to resume execution of a paused Action. If the Action is not paused, it does nothing.
final case class ActionResume(id: Sequence.Id, i: Int, cont: IO[Result]) extends UserEvent[Nothing] {
  val user: Option[UserDetails] = None
}

final case class LogDebug(msg: String) extends UserEvent[Nothing] {
  val user: Option[UserDetails] = None
}

final case class LogInfo(msg: String) extends UserEvent[Nothing] {
  val user: Option[UserDetails] = None
}

final case class LogWarning(msg: String) extends UserEvent[Nothing] {
  val user: Option[UserDetails] = None
}

final case class LogError(msg: String) extends UserEvent[Nothing] {
  val user: Option[UserDetails] = None
}
