package edu.gemini.seqexec.engine

/**
  * Anything that can go through the Event Queue.
  */
sealed trait Event
case class EventUser(ue: UserEvent) extends Event
case class EventSystem(se: SystemEvent) extends Event

/**
  * Events generated by the user.
  */
sealed trait UserEvent
case class Start(id: Sequence.Id) extends UserEvent
case class Pause(id: Sequence.Id) extends UserEvent
case class Load(id: Sequence.Id, sequence: Sequence[Action]) extends UserEvent
case object Poll extends UserEvent
case object Exit extends UserEvent

/**
  * Events generated internally by the Engine.
  */
sealed trait SystemEvent
case class Completed[R](id: Sequence.Id, i: Int, r: R) extends SystemEvent
case class Failed[E](id: Sequence.Id, i: Int, e: E) extends SystemEvent
case class Executed(id: Sequence.Id) extends SystemEvent
case class Finished(id: Sequence.Id) extends SystemEvent

object Event {

  def start(id: Sequence.Id): Event = EventUser(Start(id))
  def pause(id: Sequence.Id): Event = EventUser(Pause(id))
  val poll: Event = EventUser(Poll)
  val exit: Event = EventUser(Exit)
  def load(id: Sequence.Id, sequence: Sequence[Action]): Event = EventUser(Load(id, sequence))

  def completed[R](id: Sequence.Id, i: Int, r: R): Event = EventSystem(Completed(id, i, r))
  def failed[E](id: Sequence.Id, i: Int, e: E): Event = EventSystem(Failed(id, i, e))
  def executed(id: Sequence.Id): Event = EventSystem(Executed(id))
  def finished(id: Sequence.Id): Event = EventSystem(Finished(id))

}
